# 总体结构图

![](https://raw.githubusercontent.com/fly-t/images/main/blog/README-2025-08-01-23-41-27.png)
     

✅ 三、模块职责清晰划分
1. GPIO 中断服务函数
中断类型：ANYEDGE（上升沿+下降沿）

功能：

读取引脚电平

将 按下/释放 事件推入 FreeRTOS 队列

中断中不做复杂逻辑，保持简洁、快速

2. FreeRTOS 队列任务 (gpio_task_example)
功能：

接收事件（按下/释放）

启动/停止定时器

控制点击计数器 click_count

判断状态并委托给定时器

3. 双击检测定时器（click_timer_cb）
功能：

在第一次点击后的超时时间内，判断是否是单击或双击

400ms 到期后检查 click_count 是 1 还是 2

4. 长按检测定时器（long_press_timer_cb）
功能：

启动后 800ms，如果按键还没释放，则判定为长按

一旦触发，立刻重置状态，忽略双击逻辑

✅ 四、关键设计点详解
1. 为啥不在 ISR 做判断？
原则：ISR 越短越好，只做通知！

如果 ISR 中加逻辑处理（比如判断持续时间），容易：

引起系统响应变慢

被中断嵌套打断

导致任务调度异常或死锁

所以设计为：ISR → 推事件 → 任务异步处理。

2. 为什么双击靠软件定时器而非循环判断？
精准、非阻塞、资源轻

你可以用：

vTaskDelay() + xTaskGetTickCount() 判断间隔

但这样占 CPU，且不精确

软件定时器（Timer）是 FreeRTOS 推荐的定时方式，优势：

精度好

不占 CPU

可组合实现复杂定时状态机（例如：延迟触发 + 状态跟踪）

3. 状态清空策略？
触发某种状态后（长按/双击/单击）：

清空 click_count

停止相关定时器

等待下一个 EVENT_PRESS

这保证了事件识别之间的独立性。
